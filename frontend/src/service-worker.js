import { precacheAndRoute } from 'workbox-precaching';
import { registerRoute, setCatchHandler } from 'workbox-routing';
import { StaleWhileRevalidate, NetworkFirst, CacheFirst } from 'workbox-strategies';
import { BackgroundSyncPlugin } from 'workbox-background-sync';

// Precache all of the assets generated by your build process.
// Their URLs are injected into the manifest variable below.
precacheAndRoute(self.__WB_MANIFEST);

// Define a fallback for offline use
const FALLBACK_HTML_URL = '/index.html'; // Or a dedicated offline.html

// This assumes your app is a SPA and all navigation requests go to index.html
registerRoute(
  ({ request }) => request.mode === 'navigate',
  new NetworkFirst({
    cacheName: 'pages',
    plugins: [
      {
        cacheWillUpdate: async ({ response }) => {
          if (response.type === 'opaque') {
            return;
          }
          return response;
        },
      },
    ],
  })
);

// Cache images with a CacheFirst strategy
registerRoute(
  ({ request }) => request.destination === 'image',
  new CacheFirst({
    cacheName: 'images',
    plugins: [
      // Add a plugin to expire images after a certain time or number
      // new ExpirationPlugin({ maxEntries: 50, maxAgeSeconds: 30 * 24 * 60 * 60 }), // 30 Days
    ],
  })
);

// Background Sync for API calls (e.g., POST requests that might fail offline)
const bgSyncPlugin = new BackgroundSyncPlugin('api-queue', {
  maxRetentionTime: 24 * 60, // Retry for a maximum of 24 Hours
});

registerRoute(
  ({ url }) => url.pathname.startsWith('/api/'),
  new NetworkFirst({
    cacheName: 'api-cache',
    plugins: [
      bgSyncPlugin,
      // Add a plugin to expire API responses after a certain time or number
      // new ExpirationPlugin({ maxEntries: 50, maxAgeSeconds: 5 * 60 }), // 5 Minutes
    ],
  })
);

// Offline fallback for navigation requests
setCatchHandler(async ({ event }) => {
  if (event.request.mode === 'navigate') {
    return caches.match(FALLBACK_HTML_URL);
  }
  return Response.error();
});

// Push Notification handling
self.addEventListener('push', (event) => {
  const data = event.data.json();
  const title = data.title || 'CordoEats';
  const options = {
    body: data.body || 'Tienes una nueva notificaciÃ³n.',
    icon: data.icon || '/logo192.png',
    badge: data.badge || '/logo192.png',
    data: {
      url: data.url || '/',
    },
  };

  event.waitUntil(self.registration.showNotification(title, options));
});

self.addEventListener('notificationclick', (event) => {
  event.notification.close();
  event.waitUntil(
    clients.openWindow(event.notification.data.url)
  );
});

// App Update Notifications (handled in serviceWorkerRegistration.js and App.js)
// This part is more about communicating from SW to the main app
// and is already partially covered by the existing setup.
